# Feature 05: Timer e Pomodoro

## Contexto e Objetivo

**Prioridade:** üü¢ Baixa  
**Estimativa:** 3-4 horas  
**Tipo:** Feature

Adicionar timer Pomodoro para foco durante trabalho em tickets, ajudando desenvolvedores a gerenciar tempo e manter produtividade.

## Requisitos T√©cnicos

### Depend√™ncias

N√£o requer depend√™ncias adicionais.

### APIs Utilizadas

- `setInterval` / `clearInterval` para countdown
- `localStorage` para persist√™ncia de estado
- `Notification API` para notifica√ß√µes (opcional)
- `Audio API` para som de notifica√ß√£o

## Arquitetura e Design

### M√°quina de Estados

```
IDLE
  ‚Üì start()
WORKING (25min)
  ‚Üì complete
BREAK (5min)
  ‚Üì complete
WORKING (25min)
  ...
```

### Estados do Timer

- **idle**: Timer n√£o iniciado
- **working**: Per√≠odo de trabalho (25min default)
- **break**: Per√≠odo de descanso (5min default)
- **paused**: Timer pausado (pode voltar para working ou break)

## Arquivos a Criar

### 1. `src/app/hooks/usePomodoro.ts`

**Responsabilidade:** L√≥gica completa do timer Pomodoro.

```typescript
import { useState, useEffect, useRef, useCallback } from 'react';

export type PomodoroStatus = 'idle' | 'working' | 'break' | 'paused';

export interface PomodoroConfig {
  workDuration: number; // em minutos
  breakDuration: number; // em minutos
  longBreakDuration: number; // em minutos
  pomodorosUntilLongBreak: number;
}

export interface PomodoroState {
  status: PomodoroStatus;
  timeLeft: number; // em segundos
  totalTime: number; // em segundos
  completedPomodoros: number;
  currentTicketId?: string;
}

const DEFAULT_CONFIG: PomodoroConfig = {
  workDuration: 25,
  breakDuration: 5,
  longBreakDuration: 15,
  pomodorosUntilLongBreak: 4,
};

const STORAGE_KEY = 'pomodoro-state';

export const usePomodoro = (config: Partial<PomodoroConfig> = {}) => {
  const fullConfig = { ...DEFAULT_CONFIG, ...config };
  
  const [state, setState] = useState<PomodoroState>(() => {
    // Carregar estado do localStorage
    const saved = localStorage.getItem(STORAGE_KEY);
    if (saved) {
      return JSON.parse(saved);
    }
    return {
      status: 'idle',
      timeLeft: fullConfig.workDuration * 60,
      totalTime: fullConfig.workDuration * 60,
      completedPomodoros: 0,
    };
  });
  
  const intervalRef = useRef<number | null>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  
  // Persistir estado no localStorage
  useEffect(() => {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }, [state]);
  
  // Countdown logic
  useEffect(() => {
    if (state.status === 'working' || state.status === 'break') {
      intervalRef.current = window.setInterval(() => {
        setState(prev => {
          if (prev.timeLeft <= 1) {
            // Timer completado
            handleTimerComplete(prev);
            return prev;
          }
          return {
            ...prev,
            timeLeft: prev.timeLeft - 1,
          };
        });
      }, 1000);
      
      return () => {
        if (intervalRef.current) {
          clearInterval(intervalRef.current);
        }
      };
    }
  }, [state.status]);
  
  const handleTimerComplete = useCallback((currentState: PomodoroState) => {
    // Play notification sound
    playNotificationSound();
    
    // Show browser notification
    showNotification(currentState.status);
    
    // Atualizar estado
    if (currentState.status === 'working') {
      const newCompletedPomodoros = currentState.completedPomodoros + 1;
      const isLongBreak = newCompletedPomodoros % fullConfig.pomodorosUntilLongBreak === 0;
      const breakDuration = isLongBreak ? fullConfig.longBreakDuration : fullConfig.breakDuration;
      
      setState({
        status: 'break',
        timeLeft: breakDuration * 60,
        totalTime: breakDuration * 60,
        completedPomodoros: newCompletedPomodoros,
        currentTicketId: currentState.currentTicketId,
      });
    } else if (currentState.status === 'break') {
      setState({
        status: 'working',
        timeLeft: fullConfig.workDuration * 60,
        totalTime: fullConfig.workDuration * 60,
        completedPomodoros: currentState.completedPomodoros,
        currentTicketId: currentState.currentTicketId,
      });
    }
  }, [fullConfig]);
  
  const start = useCallback((ticketId?: string) => {
    setState({
      status: 'working',
      timeLeft: fullConfig.workDuration * 60,
      totalTime: fullConfig.workDuration * 60,
      completedPomodoros: 0,
      currentTicketId: ticketId,
    });
  }, [fullConfig]);
  
  const pause = useCallback(() => {
    setState(prev => ({
      ...prev,
      status: 'paused',
    }));
  }, []);
  
  const resume = useCallback(() => {
    setState(prev => ({
      ...prev,
      status: prev.totalTime === fullConfig.workDuration * 60 ? 'working' : 'break',
    }));
  }, [fullConfig]);
  
  const reset = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
    }
    setState({
      status: 'idle',
      timeLeft: fullConfig.workDuration * 60,
      totalTime: fullConfig.workDuration * 60,
      completedPomodoros: 0,
    });
  }, [fullConfig]);
  
  const skip = useCallback(() => {
    handleTimerComplete(state);
  }, [state, handleTimerComplete]);
  
  const playNotificationSound = () => {
    if (!audioRef.current) {
      audioRef.current = new Audio('/notification.mp3'); // Adicionar arquivo de som
    }
    audioRef.current.play().catch(() => {
      // Ignorar erro se autoplay bloqueado
    });
  };
  
  const showNotification = (status: PomodoroStatus) => {
    if ('Notification' in window && Notification.permission === 'granted') {
      const title = status === 'working' ? 'Work session complete!' : 'Break complete!';
      const body = status === 'working' 
        ? 'Time for a break! üéâ' 
        : 'Ready to focus again? üí™';
      
      new Notification(title, {
        body,
        icon: '/logo.svg',
      });
    }
  };
  
  const requestNotificationPermission = async () => {
    if ('Notification' in window && Notification.permission === 'default') {
      await Notification.requestPermission();
    }
  };
  
  // Formatters
  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };
  
  const getProgress = (): number => {
    return ((state.totalTime - state.timeLeft) / state.totalTime) * 100;
  };
  
  return {
    state,
    start,
    pause,
    resume,
    reset,
    skip,
    formatTime: () => formatTime(state.timeLeft),
    getProgress,
    requestNotificationPermission,
  };
};
```

---

### 2. `src/app/components/ui/Pomodoro.tsx`

**Responsabilidade:** Componente visual do timer.

```typescript
import React from 'react';
import { usePomodoro, PomodoroStatus } from '@/app/hooks/usePomodoro';
import { Button } from '@/app/components/ui/button';
import { Card, CardContent } from '@/app/components/ui/card';
import { Progress } from '@/app/components/ui/progress';
import { Play, Pause, RotateCcw, SkipForward, Bell } from 'lucide-react';
import { cn } from '@/lib/utils';

interface PomodoroProps {
  ticketId?: string;
  compact?: boolean;
}

export const Pomodoro: React.FC<PomodoroProps> = ({ ticketId, compact = false }) => {
  const {
    state,
    start,
    pause,
    resume,
    reset,
    skip,
    formatTime,
    getProgress,
    requestNotificationPermission,
  } = usePomodoro();
  
  const getStatusColor = (status: PomodoroStatus): string => {
    switch (status) {
      case 'working': return 'text-red-500';
      case 'break': return 'text-green-500';
      case 'paused': return 'text-yellow-500';
      default: return 'text-gray-500';
    }
  };
  
  const getStatusText = (status: PomodoroStatus): string => {
    switch (status) {
      case 'working': return 'Focus Time üéØ';
      case 'break': return 'Break Time ‚òï';
      case 'paused': return 'Paused ‚è∏Ô∏è';
      default: return 'Ready to start';
    }
  };
  
  if (compact) {
    return (
      <div className="flex items-center gap-2">
        <span className={cn('font-mono text-sm', getStatusColor(state.status))}>
          {formatTime()}
        </span>
        {state.status === 'idle' && (
          <Button size="sm" variant="outline" onClick={() => start(ticketId)}>
            <Play className="h-3 w-3" />
          </Button>
        )}
        {(state.status === 'working' || state.status === 'break') && (
          <Button size="sm" variant="outline" onClick={pause}>
            <Pause className="h-3 w-3" />
          </Button>
        )}
        {state.status === 'paused' && (
          <Button size="sm" variant="outline" onClick={resume}>
            <Play className="h-3 w-3" />
          </Button>
        )}
      </div>
    );
  }
  
  return (
    <Card>
      <CardContent className="pt-6">
        <div className="flex flex-col items-center space-y-4">
          {/* Status */}
          <div className={cn('text-sm font-medium', getStatusColor(state.status))}>
            {getStatusText(state.status)}
          </div>
          
          {/* Timer */}
          <div className="text-6xl font-mono font-bold">
            {formatTime()}
          </div>
          
          {/* Progress bar */}
          <Progress value={getProgress()} className="w-full" />
          
          {/* Pomodoros completados */}
          <div className="text-sm text-muted-foreground">
            Pomodoros completed: {state.completedPomodoros} üçÖ
          </div>
          
          {/* Controls */}
          <div className="flex gap-2">
            {state.status === 'idle' && (
              <>
                <Button onClick={() => start(ticketId)}>
                  <Play className="mr-2 h-4 w-4" />
                  Start
                </Button>
                <Button 
                  variant="outline" 
                  onClick={requestNotificationPermission}
                  title="Enable notifications"
                >
                  <Bell className="h-4 w-4" />
                </Button>
              </>
            )}
            
            {(state.status === 'working' || state.status === 'break') && (
              <>
                <Button onClick={pause}>
                  <Pause className="mr-2 h-4 w-4" />
                  Pause
                </Button>
                <Button variant="outline" onClick={skip}>
                  <SkipForward className="h-4 w-4" />
                </Button>
                <Button variant="outline" onClick={reset}>
                  <RotateCcw className="h-4 w-4" />
                </Button>
              </>
            )}
            
            {state.status === 'paused' && (
              <>
                <Button onClick={resume}>
                  <Play className="mr-2 h-4 w-4" />
                  Resume
                </Button>
                <Button variant="outline" onClick={reset}>
                  <RotateCcw className="mr-2 h-4 w-4" />
                  Reset
                </Button>
              </>
            )}
          </div>
          
          {/* Keyboard shortcuts hint */}
          <div className="text-xs text-muted-foreground">
            Tip: Press <kbd className="kbd">Cmd</kbd> + <kbd className="kbd">P</kbd> to pause/resume
          </div>
        </div>
      </CardContent>
    </Card>
  );
};
```

## Arquivos a Editar

### 1. `src/app/pages/TicketEditPage.tsx`

**Mudan√ßas:** Integrar widget Pomodoro.

```typescript
import { Pomodoro } from '@/app/components/ui/Pomodoro';

// No JSX, adicionar ap√≥s header ou em sidebar:

<div className="mb-6">
  <Pomodoro ticketId={ticket?.id} />
</div>
```

### 2. `src/app/components/layouts/MainLayout.tsx` (Opcional)

**Mudan√ßas:** Adicionar Pomodoro compacto no header.

```typescript
import { Pomodoro } from '@/app/components/ui/Pomodoro';

// No header:

<div className="flex items-center gap-4">
  <Pomodoro compact />
  {/* ... outros elementos do header */}
</div>
```

### 3. `src/app/hooks/useKeyboardShortcuts.ts`

**Mudan√ßas:** Adicionar atalho Cmd+P para Pomodoro.

```typescript
// Adicionar handler:
useEffect(() => {
  const handler = (e: KeyboardEvent) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'p') {
      e.preventDefault();
      // Toggle pomodoro play/pause
      // Precisa de refer√™ncia ao hook usePomodoro
    }
  };
  
  window.addEventListener('keydown', handler);
  return () => window.removeEventListener('keydown', handler);
}, []);
```

## Plano de Implementa√ß√£o Detalhado

### Fase 1: Hook Logic (1.5-2h)

1. **Criar `usePomodoro.ts`**
   - Estados b√°sicos
   - Countdown logic
   - Persist√™ncia em localStorage

2. **Implementar transi√ß√µes de estado**
   - work ‚Üí break
   - break ‚Üí work
   - pause/resume

3. **Testar hook isoladamente**
   - Unit tests ou testes manuais
   - Verificar persist√™ncia

### Fase 2: UI Component (1h)

4. **Criar `Pomodoro.tsx`**
   - Modo normal (card)
   - Modo compact

5. **Estilizar componente**
   - Cores por status
   - Progress bar
   - Animations

### Fase 3: Notifica√ß√µes (30min)

6. **Implementar notifica√ß√µes**
   - Browser notifications
   - Som de notifica√ß√£o
   - Permiss√µes

7. **Adicionar arquivo de som**
   - `public/notification.mp3`
   - Testar playback

### Fase 4: Integra√ß√£o (30min-1h)

8. **Integrar em `TicketEditPage.tsx`**
   - Adicionar widget
   - Passar ticketId

9. **Integrar em `MainLayout.tsx` (opcional)**
   - Modo compact no header
   - Acess√≠vel de qualquer p√°gina

10. **Adicionar atalhos de teclado**
    - Cmd+P para play/pause

### Fase 5: Polish (30min)

11. **Refinamentos**
    - Loading states
    - Error handling
    - Accessibility

12. **Testes finais**
    - Timer completo (work + break)
    - M√∫ltiplos pomodoros
    - Persist√™ncia entre reloads

## Estruturas de Dados

### PomodoroState em localStorage

```json
{
  "status": "working",
  "timeLeft": 1200,
  "totalTime": 1500,
  "completedPomodoros": 2,
  "currentTicketId": "ticket-123"
}
```

### PomodoroConfig

```typescript
{
  workDuration: 25,        // minutos
  breakDuration: 5,        // minutos
  longBreakDuration: 15,   // minutos
  pomodorosUntilLongBreak: 4
}
```

## Casos de Uso

### Caso 1: Iniciar Pomodoro ao Trabalhar em Ticket

1. Developer abre ticket
2. Clica em "Start" no widget Pomodoro
3. Timer inicia (25min)
4. Developer trabalha focado
5. Timer termina e toca notifica√ß√£o
6. Break autom√°tico come√ßa (5min)
7. Developer descansa
8. Timer termina e toca notifica√ß√£o
9. Novo ciclo de trabalho come√ßa

### Caso 2: Pausar e Retomar

1. Developer est√° em pomodoro ativo
2. Interrup√ß√£o urgente acontece
3. Developer clica "Pause"
4. Timer pausa
5. Ap√≥s resolver interrup√ß√£o, clica "Resume"
6. Timer continua de onde parou

### Caso 3: Skip Break

1. Developer completa work session
2. Break autom√°tico come√ßa
3. Developer se sente bem, n√£o precisa de break
4. Clica "Skip"
5. Pr√≥ximo work session come√ßa imediatamente

## Valida√ß√£o e Testes

### Checklist de Valida√ß√£o

- [ ] Timer inicia com 25 minutos
- [ ] Countdown funciona corretamente
- [ ] Transi√ß√£o work ‚Üí break funciona
- [ ] Transi√ß√£o break ‚Üí work funciona
- [ ] Long break acontece a cada 4 pomodoros
- [ ] Pause/resume funciona
- [ ] Reset funciona
- [ ] Skip funciona
- [ ] Estado persiste no localStorage
- [ ] Notifica√ß√£o visual aparece ao terminar
- [ ] Notifica√ß√£o sonora toca ao terminar
- [ ] Browser notification funciona (se permitido)
- [ ] Progress bar atualiza corretamente
- [ ] Contador de pomodoros atualiza
- [ ] Modo compact funciona
- [ ] Atalho Cmd+P funciona

### Cen√°rios de Erro

- [ ] Notification bloqueada pelo browser
- [ ] Autoplay de audio bloqueado
- [ ] localStorage cheio
- [ ] Timer rodando em background (aba fechada)

## Poss√≠veis Desafios e Solu√ß√µes

### Desafio 1: Timer Drift

**Problema:** `setInterval` n√£o √© preciso, pode ter drift acumulado.

**Solu√ß√£o:**
```typescript
// Usar timestamp ao inv√©s de contador
const startTime = Date.now();
const endTime = startTime + (duration * 1000);

setInterval(() => {
  const now = Date.now();
  const remaining = Math.max(0, endTime - now);
  setTimeLeft(Math.ceil(remaining / 1000));
}, 100); // Update mais frequentemente
```

### Desafio 2: Background Tabs

**Problema:** Timer pode n√£o funcionar quando aba est√° em background.

**Solu√ß√£o:**
- Salvar `endTime` no localStorage
- Ao retomar aba, calcular tempo restante baseado em timestamp
- Page Visibility API para detectar quando aba volta

```typescript
useEffect(() => {
  const handler = () => {
    if (document.visibilityState === 'visible') {
      // Recalcular tempo restante
      syncTimerFromStorage();
    }
  };
  
  document.addEventListener('visibilitychange', handler);
  return () => document.removeEventListener('visibilitychange', handler);
}, []);
```

### Desafio 3: Notifica√ß√µes Bloqueadas

**Problema:** Browser pode bloquear notifica√ß√µes.

**Solu√ß√£o:**
- Pedir permiss√£o explicitamente
- Bot√£o "Enable Notifications"
- Fallback para notifica√ß√£o visual dentro do app

### Desafio 4: Som N√£o Toca

**Problema:** Autoplay de audio pode ser bloqueado.

**Solu√ß√£o:**
- Usar audio apenas ap√≥s intera√ß√£o do usu√°rio
- Fallback para vibra√ß√£o (mobile)
- Visual notification sempre funcionar√°

## UI/UX Detalhes

### Modo Normal (Card)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Focus Time üéØ          ‚îÇ
‚îÇ                             ‚îÇ
‚îÇ        25:00                ‚îÇ
‚îÇ                             ‚îÇ
‚îÇ ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë        ‚îÇ
‚îÇ                             ‚îÇ
‚îÇ  Pomodoros completed: 2 üçÖ  ‚îÇ
‚îÇ                             ‚îÇ
‚îÇ  [‚è∏Ô∏è Pause]  [‚è≠Ô∏è]  [üîÑ]      ‚îÇ
‚îÇ                             ‚îÇ
‚îÇ  Tip: Cmd+P to pause/resume ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Modo Compact

```
üéØ 25:00 [‚è∏Ô∏è]
```

### Estados Visuais

- **Working**: Texto vermelho, barra progresso vermelha
- **Break**: Texto verde, barra progresso verde
- **Paused**: Texto amarelo, barra progresso amarela
- **Idle**: Texto cinza

## Crit√©rios de Aceite

- ‚úÖ Timer inicia/pausa/reseta
- ‚úÖ Countdown √© preciso (sem drift significativo)
- ‚úÖ Transi√ß√µes work ‚Üî break funcionam
- ‚úÖ Notifica√ß√£o ao finalizar per√≠odo (visual + sonora)
- ‚úÖ Estado persiste entre sess√µes (localStorage)
- ‚úÖ Long break a cada 4 pomodoros
- ‚úÖ Modo compact funciona
- ‚úÖ Atalho Cmd+P funciona
- ‚úÖ Progress bar reflete tempo restante
- ‚úÖ Funciona em background tabs

---

**√öltima atualiza√ß√£o:** Janeiro 2025  
**Status:** Aguardando implementa√ß√£o

